package twilightforest.client.model.entity;

import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.math.MathHelper;
import twilightforest.entity.EntityTFTowerGolem;

//Date: 3/9/2013 10:55:38 AM
//Template version 1.1
//Java generated by Techne
//Keep in mind that you still need to fill in some blanks
//- ZeuX


public class ModelTFTowerGolem extends ModelBase {
	//fields
	ModelRenderer head;
	ModelRenderer jaw;
	ModelRenderer body;
	ModelRenderer rightarm;
	ModelRenderer leftarm;
	ModelRenderer leftleg;
	ModelRenderer leftfoot;
	ModelRenderer ribs;
	ModelRenderer hips;
	ModelRenderer rightfoot;
	ModelRenderer rightleg;
	ModelRenderer spine;

	public ModelTFTowerGolem() {
		textureWidth = 128;
		textureHeight = 64;

		head = new ModelRenderer(this, 0, 0);
		head.setRotationPoint(0F, -11F, -2F);
		head.setTextureOffset(0, 0).addBox(-3.5F, -10F, -3F, 7, 8, 6); // head
		head.setTextureOffset(0, 14).addBox(-4F, -6F, -3.5F, 8, 4, 6); // jaw

		body = new ModelRenderer(this, 0, 26);
		body.addBox(-8F, 0F, -5F, 16, 10, 10);
		body.setRotationPoint(0F, -13F, 0F);

		ribs = new ModelRenderer(this, 0, 46);
		ribs.addBox(-5F, 0F, -3F, 10, 6, 6);
		ribs.setRotationPoint(0F, -3F, 0F);

		rightarm = new ModelRenderer(this, 52, 0);
		rightarm.setRotationPoint(-8F, -12F, 0F);
		rightarm.setTextureOffset(52, 0).addBox(-5F, -2F, -1.5F, 3, 14, 3); // arm
		rightarm.setTextureOffset(52, 17).addBox(-7F, 12F, -3F, 6, 12, 6); // fist
		rightarm.setTextureOffset(52, 36).addBox(-7F, -3F, -3.5F, 7, 2, 7); // shoulder top
		rightarm.setTextureOffset(52, 45).addBox(-7F, -1F, -3.5F, 7, 5, 2); // shoulder front
		rightarm.setTextureOffset(52, 45).addBox(-7F, -1F, 1.5F, 7, 5, 2); // shoulder back
		rightarm.setTextureOffset(52, 54).addBox(-2F, -1F, -2F, 2, 5, 3); // shoulder inner

		leftarm = new ModelRenderer(this, 52, 0);
		leftarm.mirror = true;
		leftarm.setRotationPoint(8F, -12F, 0F);
		leftarm.setTextureOffset(52, 0).addBox(2F, -2F, -1.5F, 3, 14, 3); // arm
		leftarm.setTextureOffset(52, 17).addBox(1F, 12F, -3F, 6, 12, 6); // fist
		leftarm.setTextureOffset(52, 36).addBox(0F, -3F, -3.5F, 7, 2, 7); // shoulder top
		leftarm.setTextureOffset(52, 45).addBox(0F, -1F, -3.5F, 7, 5, 2); // shoulder front
		leftarm.setTextureOffset(52, 45).addBox(0F, -1F, 1.5F, 7, 5, 2); // shoulder back
		leftarm.setTextureOffset(52, 54).addBox(0F, -1F, -2F, 2, 5, 3); // shoulder inner

		hips = new ModelRenderer(this, 84, 25);
		hips.addBox(-5F, 0F, -2F, 10, 3, 4);
		hips.setRotationPoint(0F, 1F, 0F);

		spine = new ModelRenderer(this, 84, 18);
		spine.addBox(-1.5F, 0F, -1.5F, 3, 4, 3);
		spine.setRotationPoint(0F, -3F, 0F);

		leftleg = new ModelRenderer(this, 84, 32);
		leftleg.mirror = true;
		leftleg.setRotationPoint(1F, 2F, 0F);
		leftleg.setTextureOffset(84, 32).addBox(0F, 0F, -1.5F, 3, 8, 3);
		leftleg.setTextureOffset(84, 43).addBox(-0.5F, 8F, -4F, 6, 14, 7);

		rightleg = new ModelRenderer(this, 84, 32);
		rightleg.setRotationPoint(-1F, 2F, 0F);
		rightleg.setTextureOffset(84, 32).addBox(-3F, 0F, -1.5F, 3, 8, 3);
		rightleg.setTextureOffset(84, 43).addBox(-5.5F, 8F, -4F, 6, 14, 7);

	}


	@Override
	public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5) {
		//super.render(entity, f, f1, f2, f3, f4, f5);
		setRotationAngles(f, f1, f2, f3, f4, f5, entity);
		head.render(f5);
		body.render(f5);
		rightarm.render(f5);
		leftarm.render(f5);
		rightleg.render(f5);
		leftleg.render(f5);
		ribs.render(f5);
		hips.render(f5);
		spine.render(f5);
	}

	/**
	 * Sets the model's various rotation angles. For bipeds, par1 and par2 are used for animating the movement of arms
	 * and legs, where par1 represents the time(so that arms and legs swing back and forth) and par2 represents how
	 * "far" arms and legs can swing at most.
	 */
	@Override
	public void setRotationAngles(float par1, float par2, float par3, float par4, float par5, float par6, Entity par7Entity) {
		this.head.rotateAngleY = par4 / (180F / (float) Math.PI);
		this.head.rotateAngleX = par5 / (180F / (float) Math.PI);
		this.leftleg.rotateAngleX = -1.5F * this.func_78172_a(par1, 13.0F) * par2;
		this.rightleg.rotateAngleX = 1.5F * this.func_78172_a(par1, 13.0F) * par2;
		this.leftleg.rotateAngleY = 0.0F;
		this.rightleg.rotateAngleY = 0.0F;

//        this.leftleg.rotateAngleX = MathHelper.cos(par1 * 0.6662F) * 1.4F * par2; // biped leg movement
//        this.rightleg.rotateAngleX = MathHelper.cos(par1 * 0.6662F + (float)Math.PI) * 1.4F * par2;


		this.rightarm.rotateAngleZ = MathHelper.cos(par3 * 0.09F) * 0.05F + 0.05F;
		this.leftarm.rotateAngleZ = -MathHelper.cos(par3 * 0.09F) * 0.05F - 0.05F;

	}


	/**
	 * Used for easily adding entity-dependent animations. The second and third float params here are the same second
	 * and third as in the setRotationAngles method.
	 */
	@Override
	public void setLivingAnimations(EntityLivingBase par1EntityLiving, float par2, float par3, float par4) {
		EntityTFTowerGolem var5 = (EntityTFTowerGolem) par1EntityLiving;
		int var6 = var5.getAttackTimer();

		if (var6 > 0) {
			this.rightarm.rotateAngleX = -2.0F + 1.5F * this.func_78172_a((float) var6 - par4, 10.0F);
			this.leftarm.rotateAngleX = -2.0F + 1.5F * this.func_78172_a((float) var6 - par4, 10.0F);
		} else {
			this.rightarm.rotateAngleX = (-0.2F + 1.5F * this.func_78172_a(par2, 25.0F)) * par3;
			this.leftarm.rotateAngleX = (-0.2F - 1.5F * this.func_78172_a(par2, 25.0F)) * par3;
		}
	}

	private float func_78172_a(float par1, float par2) {
		return (Math.abs(par1 % par2 - par2 * 0.5F) - par2 * 0.25F) / (par2 * 0.25F);
	}
}
