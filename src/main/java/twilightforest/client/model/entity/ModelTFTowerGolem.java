package twilightforest.client.model.entity;

import net.minecraft.client.renderer.entity.model.EntityModel;
import net.minecraft.client.renderer.model.ModelRenderer;
import net.minecraft.util.math.MathHelper;
import twilightforest.entity.EntityTFTowerGolem;

//Date: 3/9/2013 10:55:38 AM
//Template version 1.1
//Java generated by Techne
//Keep in mind that you still need to fill in some blanks
//- ZeuX

public class ModelTFTowerGolem<T extends EntityTFTowerGolem> extends EntityModel<T> {
	//fields
	ModelRenderer head;
	ModelRenderer jaw;
	ModelRenderer body;
	ModelRenderer rightarm;
	ModelRenderer leftarm;
	ModelRenderer leftleg;
	ModelRenderer leftfoot;
	ModelRenderer ribs;
	ModelRenderer hips;
	ModelRenderer rightfoot;
	ModelRenderer rightleg;
	ModelRenderer spine;

	public ModelTFTowerGolem() {
		textureWidth = 128;
		textureHeight = 64;

		head = new ModelRenderer(this, 0, 0);
		head.setRotationPoint(0F, -11F, -2F);
		head.setTextureOffset(0, 0).addCuboid(-3.5F, -10F, -3F, 7, 8, 6); // head
		head.setTextureOffset(0, 14).addCuboid(-4F, -6F, -3.5F, 8, 4, 6); // jaw

		body = new ModelRenderer(this, 0, 26);
		body.addCuboid(-8F, 0F, -5F, 16, 10, 10);
		body.setRotationPoint(0F, -13F, 0F);

		ribs = new ModelRenderer(this, 0, 46);
		ribs.addCuboid(-5F, 0F, -3F, 10, 6, 6);
		ribs.setRotationPoint(0F, -3F, 0F);

		rightarm = new ModelRenderer(this, 52, 0);
		rightarm.setRotationPoint(-8F, -12F, 0F);
		rightarm.setTextureOffset(52, 0).addCuboid(-5F, -2F, -1.5F, 3, 14, 3); // arm
		rightarm.setTextureOffset(52, 17).addCuboid(-7F, 12F, -3F, 6, 12, 6); // fist
		rightarm.setTextureOffset(52, 36).addCuboid(-7F, -3F, -3.5F, 7, 2, 7); // shoulder top
		rightarm.setTextureOffset(52, 45).addCuboid(-7F, -1F, -3.5F, 7, 5, 2); // shoulder front
		rightarm.setTextureOffset(52, 45).addCuboid(-7F, -1F, 1.5F, 7, 5, 2); // shoulder back
		rightarm.setTextureOffset(52, 54).addCuboid(-2F, -1F, -2F, 2, 5, 3); // shoulder inner

		leftarm = new ModelRenderer(this, 52, 0);
		leftarm.mirror = true;
		leftarm.setRotationPoint(8F, -12F, 0F);
		leftarm.setTextureOffset(52, 0).addCuboid(2F, -2F, -1.5F, 3, 14, 3); // arm
		leftarm.setTextureOffset(52, 17).addCuboid(1F, 12F, -3F, 6, 12, 6); // fist
		leftarm.setTextureOffset(52, 36).addCuboid(0F, -3F, -3.5F, 7, 2, 7); // shoulder top
		leftarm.setTextureOffset(52, 45).addCuboid(0F, -1F, -3.5F, 7, 5, 2); // shoulder front
		leftarm.setTextureOffset(52, 45).addCuboid(0F, -1F, 1.5F, 7, 5, 2); // shoulder back
		leftarm.setTextureOffset(52, 54).addCuboid(0F, -1F, -2F, 2, 5, 3); // shoulder inner

		hips = new ModelRenderer(this, 84, 25);
		hips.addCuboid(-5F, 0F, -2F, 10, 3, 4);
		hips.setRotationPoint(0F, 1F, 0F);

		spine = new ModelRenderer(this, 84, 18);
		spine.addCuboid(-1.5F, 0F, -1.5F, 3, 4, 3);
		spine.setRotationPoint(0F, -3F, 0F);

		leftleg = new ModelRenderer(this, 84, 32);
		leftleg.mirror = true;
		leftleg.setRotationPoint(1F, 2F, 0F);
		leftleg.setTextureOffset(84, 32).addCuboid(0F, 0F, -1.5F, 3, 8, 3);
		leftleg.setTextureOffset(84, 43).addCuboid(-0.5F, 8F, -4F, 6, 14, 7);

		rightleg = new ModelRenderer(this, 84, 32);
		rightleg.setRotationPoint(-1F, 2F, 0F);
		rightleg.setTextureOffset(84, 32).addCuboid(-3F, 0F, -1.5F, 3, 8, 3);
		rightleg.setTextureOffset(84, 43).addCuboid(-5.5F, 8F, -4F, 6, 14, 7);

	}


	@Override
	public void render(T entity, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
		//super.render(entity, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
		setRotationAngles(entity, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
		head.render(scale);
		body.render(scale);
		rightarm.render(scale);
		leftarm.render(scale);
		rightleg.render(scale);
		leftleg.render(scale);
		ribs.render(scale);
		hips.render(scale);
		spine.render(scale);
	}

	/**
	 * Sets the model's various rotation angles. For bipeds, limbSwing and limbSwingAmount are used for animating the movement of arms
	 * and legs, where limbSwing represents the time(so that arms and legs swing back and forth) and limbSwingAmount represents how
	 * "far" arms and legs can swing at most.
	 */
	@Override
	public void setRotationAngles(T entity, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor) {
		this.head.rotateAngleY = netHeadYaw / (180F / (float) Math.PI);
		this.head.rotateAngleX = headPitch / (180F / (float) Math.PI);
		this.leftleg.rotateAngleX = -1.5F * this.func_78172_a(limbSwing, 13.0F) * limbSwingAmount;
		this.rightleg.rotateAngleX = 1.5F * this.func_78172_a(limbSwing, 13.0F) * limbSwingAmount;
		this.leftleg.rotateAngleY = 0.0F;
		this.rightleg.rotateAngleY = 0.0F;

//        this.leftleg.rotateAngleX = MathHelper.cos(limbSwing * 0.6662F) * 1.4F * limbSwingAmount; // biped leg movement
//        this.rightleg.rotateAngleX = MathHelper.cos(limbSwing * 0.6662F + (float)Math.PI) * 1.4F * limbSwingAmount;


		this.rightarm.rotateAngleZ = MathHelper.cos(ageInTicks * 0.09F) * 0.05F + 0.05F;
		this.leftarm.rotateAngleZ = -MathHelper.cos(ageInTicks * 0.09F) * 0.05F - 0.05F;

	}


	/**
	 * Used for easily adding entity-dependent animations. The second and third float params here are the same second
	 * and third as in the setRotationAngles method.
	 */
	@Override
	public void setLivingAnimations(T entity, float limbSwing, float limbSwingAmount, float partialTicks) {
		int var6 = entity.getAttackTimer();

		if (var6 > 0) {
			this.rightarm.rotateAngleX = -2.0F + 1.5F * this.func_78172_a((float) var6 - partialTicks, 10.0F);
			this.leftarm.rotateAngleX = -2.0F + 1.5F * this.func_78172_a((float) var6 - partialTicks, 10.0F);
		} else {
			this.rightarm.rotateAngleX = (-0.2F + 1.5F * this.func_78172_a(limbSwing, 25.0F)) * limbSwingAmount;
			this.leftarm.rotateAngleX = (-0.2F - 1.5F * this.func_78172_a(limbSwing, 25.0F)) * limbSwingAmount;
		}
	}

	private float func_78172_a(float par1, float par2) {
		return (Math.abs(par1 % par2 - par2 * 0.5F) - par2 * 0.25F) / (par2 * 0.25F);
	}
}
