package twilightforest.client.model.entity;

import com.google.common.collect.ImmutableList;
import net.minecraft.client.model.ListModel;
import net.minecraft.client.model.geom.ModelPart;
import net.minecraft.util.Mth;
import twilightforest.entity.CarminiteGolemEntity;

//Date: 3/9/2013 10:55:38 AM
//Template version 1.1
//Java generated by Techne
//Keep in mind that you still need to fill in some blanks
//- ZeuX

public class CarminiteGolemModel<T extends CarminiteGolemEntity> extends ListModel<T> {
	//fields TODO: Can we delete some of these unused fields?
	ModelPart head;
	ModelPart jaw;
	ModelPart body;
	ModelPart rightarm;
	ModelPart leftarm;
	ModelPart leftleg;
	ModelPart leftfoot;
	ModelPart ribs;
	ModelPart hips;
	ModelPart rightfoot;
	ModelPart rightleg;
	ModelPart spine;

	public CarminiteGolemModel() {
		texWidth = 128;
		texHeight = 64;

		head = new ModelPart(this, 0, 0);
		head.setPos(0F, -11F, -2F);
		head.texOffs(0, 0).addBox(-3.5F, -10F, -3F, 7, 8, 6); // head
		head.texOffs(0, 14).addBox(-4F, -6F, -3.5F, 8, 4, 6); // jaw

		body = new ModelPart(this, 0, 26);
		body.addBox(-8F, 0F, -5F, 16, 10, 10);
		body.setPos(0F, -13F, 0F);

		ribs = new ModelPart(this, 0, 46);
		ribs.addBox(-5F, 0F, -3F, 10, 6, 6);
		ribs.setPos(0F, -3F, 0F);

		rightarm = new ModelPart(this, 52, 0);
		rightarm.setPos(-8F, -12F, 0F);
		rightarm.texOffs(52, 0).addBox(-5F, -2F, -1.5F, 3, 14, 3); // arm
		rightarm.texOffs(52, 17).addBox(-7F, 12F, -3F, 6, 12, 6); // fist
		rightarm.texOffs(52, 36).addBox(-7F, -3F, -3.5F, 7, 2, 7); // shoulder top
		rightarm.texOffs(52, 45).addBox(-7F, -1F, -3.5F, 7, 5, 2); // shoulder front
		rightarm.texOffs(52, 45).addBox(-7F, -1F, 1.5F, 7, 5, 2); // shoulder back
		rightarm.texOffs(52, 54).addBox(-2F, -1F, -2F, 2, 5, 3); // shoulder inner

		leftarm = new ModelPart(this, 52, 0);
		leftarm.mirror = true;
		leftarm.setPos(8F, -12F, 0F);
		leftarm.texOffs(52, 0).addBox(2F, -2F, -1.5F, 3, 14, 3); // arm
		leftarm.texOffs(52, 17).addBox(1F, 12F, -3F, 6, 12, 6); // fist
		leftarm.texOffs(52, 36).addBox(0F, -3F, -3.5F, 7, 2, 7); // shoulder top
		leftarm.texOffs(52, 45).addBox(0F, -1F, -3.5F, 7, 5, 2); // shoulder front
		leftarm.texOffs(52, 45).addBox(0F, -1F, 1.5F, 7, 5, 2); // shoulder back
		leftarm.texOffs(52, 54).addBox(0F, -1F, -2F, 2, 5, 3); // shoulder inner

		hips = new ModelPart(this, 84, 25);
		hips.addBox(-5F, 0F, -2F, 10, 3, 4);
		hips.setPos(0F, 1F, 0F);

		spine = new ModelPart(this, 84, 18);
		spine.addBox(-1.5F, 0F, -1.5F, 3, 4, 3);
		spine.setPos(0F, -3F, 0F);

		leftleg = new ModelPart(this, 84, 32);
		leftleg.mirror = true;
		leftleg.setPos(1F, 2F, 0F);
		leftleg.texOffs(84, 32).addBox(0F, 0F, -1.5F, 3, 8, 3);
		leftleg.texOffs(84, 43).addBox(-0.5F, 8F, -4F, 6, 14, 7);

		rightleg = new ModelPart(this, 84, 32);
		rightleg.setPos(-1F, 2F, 0F);
		rightleg.texOffs(84, 32).addBox(-3F, 0F, -1.5F, 3, 8, 3);
		rightleg.texOffs(84, 43).addBox(-5.5F, 8F, -4F, 6, 14, 7);
	}

    @Override
	public Iterable<ModelPart> parts() {
		return ImmutableList.of(
				head,
				body,
				rightarm,
				leftarm,
				rightleg,
				leftleg,
				ribs,
				hips,
				spine
		);
	}

	/**
	 * Sets the model's various rotation angles. For bipeds, limbSwing and limbSwingAmount are used for animating the movement of arms
	 * and legs, where limbSwing represents the time(so that arms and legs swing back and forth) and limbSwingAmount represents how
	 * "far" arms and legs can swing at most.
	 */
	@Override
	public void setupAnim(T entity, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch) {
		this.head.yRot = netHeadYaw / (180F / (float) Math.PI);
		this.head.xRot = headPitch / (180F / (float) Math.PI);
		this.leftleg.xRot = -1.5F * this.func_78172_a(limbSwing, 13.0F) * limbSwingAmount;
		this.rightleg.xRot = 1.5F * this.func_78172_a(limbSwing, 13.0F) * limbSwingAmount;
		this.leftleg.yRot = 0.0F;
		this.rightleg.yRot = 0.0F;


        this.rightarm.zRot = Mth.cos(ageInTicks * 0.09F) * 0.05F + 0.05F;
		this.leftarm.zRot = -Mth.cos(ageInTicks * 0.09F) * 0.05F - 0.05F;
	}

	/**
	 * Used for easily adding entity-dependent animations. The second and third float params here are the same second
	 * and third as in the setRotationAngles method.
	 */
	@Override
	public void prepareMobModel(T entity, float limbSwing, float limbSwingAmount, float partialTicks) {
		int var6 = entity.getAttackTimer();

		if (var6 > 0) {
			this.rightarm.xRot = -2.0F + 1.5F * this.func_78172_a(var6 - partialTicks, 10.0F);
			this.leftarm.xRot = -2.0F + 1.5F * this.func_78172_a(var6 - partialTicks, 10.0F);
		} else {
			this.rightarm.xRot = (-0.2F + 1.5F * this.func_78172_a(limbSwing, 25.0F)) * limbSwingAmount;
			this.leftarm.xRot = (-0.2F - 1.5F * this.func_78172_a(limbSwing, 25.0F)) * limbSwingAmount;
		}
	}

	private float func_78172_a(float par1, float par2) {
		return (Math.abs(par1 % par2 - par2 * 0.5F) - par2 * 0.25F) / (par2 * 0.25F);
	}
}
